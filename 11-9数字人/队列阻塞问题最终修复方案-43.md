# 队列阻塞问题最终修复方案（基于 GitHub Issues）

## 问题分析

根据日志 `dh.log (469-478)` 和 GitHub Issues（#50, #48），问题表现为：

1. **任务在 init_wh 完成之前就失败**
   - 任务失败时间：15:35:48（14.77秒后）
   - init_wh 完成时间：15:35:54（20.33秒后）
   - 时间差：6秒

2. **任务状态被设置为错误**
   - `task_result = (<Status.error: 3>, 0, '', '')`
   - 异常信息为空

3. **没有看到队列启动日志**
   - 没有看到 "任务视频驱动队列启动" 的日志

## GitHub Issues 参考

根据 GitHub Issues 页面（https://github.com/Holasyb918/HeyGem-Linux-Python-Hack/issues?q=is%3Aissue%20state%3Aclosed&page=2）：

1. **#50: "24G显卡同时跑3个任务进程，出现队列阻塞问题！！"** - 2025-05-14
2. **#48: "多进程队列的异常的原因是什么"** - 2025-05-09

## 根本原因

### 1. 任务执行是异步的，但检查逻辑有问题

- `self.task.work()` 是异步执行的，启动子进程处理任务
- 任务状态可能在执行过程中被设置为错误
- 但错误信息没有正确传递到主线程

### 2. 任务可能在队列启动前失败

- 任务可能在 init_wh 完成后，但在队列启动前失败
- 可能是资源竞争或其他问题导致

### 3. 多进程环境下的资源竞争

- 多个进程可能竞争 GPU 资源
- 可能导致某些操作失败或超时

## 修复方案

### 1. 改进任务状态检查逻辑

**关键修复**:
1. **等待 init_wh 完成** - 使用轮询方式等待，而不是简单的 sleep
2. **增加等待时间** - init_wh 等待时间从 25 秒增加到 30 秒
3. **增加任务超时时间** - 从 5 分钟增加到 10 分钟
4. **改进错误处理** - 如果任务状态为错误，等待 60 秒看是否会恢复

### 2. 改进错误判断逻辑

**关键修复**:
1. **错误状态确认** - 如果任务状态为错误，等待 60 秒确认
2. **队列阻塞处理** - 根据 GitHub Issues，错误状态可能是队列阻塞，需要等待恢复
3. **结果文件检查** - 如果结果文件存在，可能是部分成功

### 3. 增加日志记录

**关键修复**:
1. **定期日志记录** - 每 10 秒记录一次初始化状态
2. **详细错误日志** - 记录错误状态的详细信息
3. **任务状态日志** - 记录任务状态的每个变化

## 修复代码

### 主要修改

1. **初始化任务状态**
   ```python
   if code not in self.task.task_dic:
       self.task.task_dic[code] = ""
   ```

2. **等待 init_wh 完成（轮询方式）**
   ```python
   init_wh_wait_time = 30  # 等待 30 秒
   init_wh_start_time = time.time()
   while time.time() - init_wh_start_time < init_wh_wait_time:
       # 检查任务状态
       if task_result != "":
           # 检查是否是错误状态
           if status.name == 'error':
               logger.warning(f"[{code}] 检测到错误状态，但在 init_wh 阶段，继续等待...")
           else:
               init_wh_completed = True
               break
       time.sleep(2)
   ```

3. **改进错误处理（队列阻塞处理）**
   ```python
   if status.name == 'error':
       if result_path and os.path.exists(result_path):
           # 如果结果文件存在，可能是部分成功
           logger.warning(f"[{code}] 任务状态为错误，但结果文件存在: {result_path}")
           task_completed = True
           break
       else:
           # 真正的错误，但可能是队列阻塞，等待恢复
           if not error_confirmed:
               logger.warning(f"[{code}] 检测到任务状态为错误，可能是队列阻塞，等待恢复（最多 60 秒）...")
               error_wait_start = time.time()
               error_confirmed = True
           
           # 如果错误状态持续超过 60 秒，才判定为失败
           if error_wait_start and time.time() - error_wait_start > 60:
               logger.error(f"[{code}] 任务状态为错误已持续 60 秒，判定为失败")
               task_completed = True
               break
   ```

4. **增加任务超时时间**
   ```python
   max_wait_time = 600  # 最大等待 10 分钟（增加超时时间）
   wait_interval = 3    # 每 3 秒检查一次
   ```

## 预期效果

### 修复后

1. **避免过早检查** - 等待 init_wh 完成后再检查任务状态
2. **队列阻塞处理** - 如果任务状态为错误，等待 60 秒看是否会恢复
3. **更准确的错误判断** - 只有错误状态持续 60 秒才判定为失败
4. **更好的日志记录** - 增加详细的日志记录，帮助诊断问题

## 验证方法

### 1. 测试功能

通过 Web 界面测试数字人生成功能，观察是否还有任务失败的问题。

### 2. 监控日志

观察日志中是否有以下信息：
- "等待任务初始化完成（init_wh）..."
- "检测到任务状态为错误，可能是队列阻塞，等待恢复（最多 60 秒）..."
- "任务成功完成" 或 "任务状态为错误已持续 60 秒，判定为失败"

### 3. 检查任务执行时间

观察任务执行时间是否正常：
- init_wh 通常需要 15-25 秒
- 任务总耗时应该在合理范围内

## 注意事项

### 1. 等待时间

- init_wh 等待时间：30 秒（确保 init_wh 完成）
- 任务总超时时间：10 分钟（600 秒）
- 错误状态等待时间：60 秒（等待队列阻塞恢复）
- 检查间隔：3 秒

### 2. 性能影响

- 增加等待时间可能会增加任务总耗时
- 但可以避免误判任务为失败
- 提高任务成功率

### 3. 错误处理

- 如果任务状态为错误，会等待 60 秒看是否会恢复
- 如果错误状态持续超过 60 秒，才判定为失败
- 如果结果文件存在，可能是部分成功

## 更新日期

2025-11-09

## 相关文件

- `app.py` - 已修复（基于 GitHub Issues 的解决方案）
- `队列阻塞问题根本解决方案_基于GitHubIssues.md` - 详细分析文档

