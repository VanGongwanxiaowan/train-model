# 队列阻塞问题原因分析

## 问题描述
任务 ID: 996f0706-bd4e-11f0-aa21-0242ac110003

### 日志分析
```
[2025-11-09 17:29:40,287] [INFO] [drivered_video >>>>>>>>>>>>>>>>>>>> 发送数据大小:[1], current_idx:1]
[2025-11-09 17:29:40,322] [INFO] [drivered_video >>>>>>>>>>>>>>>>>>>> 发送数据大小:[1], current_idx:10]
[2025-11-09 17:30:40,324] [ERROR] [任务视频驱动队列满，严重阻塞，下游队列异常]
```

### 问题现象
1. **数据发送**: 成功发送了10个数据（current_idx:1 到 current_idx:10）
2. **阻塞时间**: 60秒后（17:29:40 到 17:30:40）出现队列阻塞
3. **错误信息**: "任务视频驱动队列满，严重阻塞，下游队列异常"
4. **GPU 利用率**: **0%** ❌（所有 GPU 利用率都为 0%）

## 根本原因分析

### 核心问题：GPU 未被使用

#### 1. GPU 利用率检查结果
- **所有 GPU 利用率**: 0%
- **GPU 内存使用**: 正常（40-50 GB），但利用率為 0%
- **问题**: GPU 完全没有被使用，任务在 CPU 上运行

#### 2. 为什么 GPU 未被使用？

##### 原因 1: 服务启动时环境变量已设置，但子进程可能未继承
- **检查结果**: 主进程的 LD_LIBRARY_PATH 已设置: `/opt/conda/envs/human/lib:/usr/local/nvidia/lib:/usr/local/nvidia/lib64`
- **问题**: 多进程环境下，子进程可能没有继承环境变量
- **影响**: 子进程无法找到 cuDNN 库，回退到 CPU

##### 原因 2: trans_dh_service.so 是编译后的文件
- **文件**: `trans_dh_service.cpython-38-x86_64-linux-gnu.so` (16 MB)
- **问题**: 编译后的 .so 文件可能在运行时没有正确加载 GPU 库
- **影响**: 即使环境变量正确，也可能无法使用 GPU

##### 原因 3: 多进程环境下环境变量传递问题
- **问题**: `multiprocessing.spawn` 方式创建的子进程可能没有正确继承环境变量
- **影响**: 子进程无法使用 GPU，导致处理速度慢

##### 原因 4: ONNX Runtime 实际运行时可能回退到 CPU
- **问题**: 虽然检查脚本显示 GPU 可用，但实际运行时可能因为环境变量问题回退到 CPU
- **影响**: ONNX Runtime 使用 CPU，处理速度慢

### 3. 为什么 GPU 未使用会导致队列阻塞？

#### 处理速度对比
- **GPU 处理**: 每帧可能需要几毫秒到几十毫秒
- **CPU 处理**: 每帧可能需要几秒到几十秒
- **速度差距**: GPU 比 CPU 快 10-100 倍

#### 队列阻塞机制
1. **数据产生速度快**: 视频帧数据快速进入队列（batch_size:1, len:150）
2. **处理速度慢**: CPU 处理速度远慢于数据产生速度
3. **队列填满**: 队列快速填满（仅处理了10/150个数据）
4. **阻塞**: 队列填满后阻塞，无法继续处理

#### 具体分析
- **总数据量**: 150 帧
- **已处理**: 10 帧（6.7%）
- **处理时间**: 60 秒
- **处理速度**: 约 0.17 帧/秒（CPU 处理）
- **预计总时间**: 150 / 0.17 ≈ 882 秒（约 15 分钟）
- **队列阻塞**: 60 秒后队列填满，阻塞

## 解决方案

### 方案 1: 确保子进程环境变量正确（最关键）

#### 问题
- 主进程环境变量已设置，但子进程可能未继承
- multiprocessing.spawn 方式创建的子进程可能没有正确继承环境变量

#### 解决方案
在 app.py 中，在设置环境变量后，确保子进程能继承：
```python
# 在 app.py 开头设置环境变量
os.environ["LD_LIBRARY_PATH"] = "/opt/conda/envs/human/lib:" + os.environ.get("LD_LIBRARY_PATH", "")

# 确保 multiprocessing 子进程继承环境变量
import multiprocessing
multiprocessing.set_start_method("spawn", force=True)

# 在创建子进程前，再次设置环境变量
os.environ["LD_LIBRARY_PATH"] = "/opt/conda/envs/human/lib:" + os.environ.get("LD_LIBRARY_PATH", "")
```

#### 为什么有效？
- **确保环境变量设置**: 在多个位置设置环境变量，确保子进程能继承
- **传递给子进程**: 环境变量会传递给所有子进程
- **ONNX Runtime 能找到库**: LD_LIBRARY_PATH 确保 cuDNN 库能被找到

### 方案 2: 使用启动脚本确保环境变量正确

#### 问题
- 服务启动时环境变量可能没有正确设置
- 需要确保所有环境变量在服务启动前设置

#### 解决方案
使用启动脚本 `启动服务.sh`，确保环境变量正确设置：
```bash
export LD_LIBRARY_PATH=/opt/conda/envs/human/lib:$LD_LIBRARY_PATH
export ORT_PARALLEL=0
export OMP_WAIT_POLICY=ACTIVE
export ORT_LOGGING_LEVEL=3
python app.py
```

#### 为什么有效？
- **确保环境变量设置**: 启动脚本确保所有环境变量正确设置
- **传递给子进程**: 环境变量会传递给所有子进程
- **ONNX Runtime 能找到库**: LD_LIBRARY_PATH 确保 cuDNN 库能被找到

### 方案 3: 检查 trans_dh_service.so 的 GPU 支持

#### 问题
- trans_dh_service 是编译后的 .so 文件
- 可能编译时未链接 GPU 库
- 即使环境变量正确，也可能无法使用 GPU

#### 解决方案
1. **检查 .so 文件依赖**: 使用 `ldd` 检查依赖
2. **检查编译配置**: 查看编译时的配置
3. **重新编译**: 如果必要，重新编译以支持 GPU

### 方案 4: 监控实际运行时的 GPU 使用

#### 问题
- 检查脚本显示 GPU 可用，但实际运行时可能没有使用
- 需要验证实际运行时的 GPU 使用情况

#### 解决方案
1. **监控 GPU 使用**: 在任务执行时监控 GPU 利用率
2. **检查日志**: 查看是否有 ONNX Runtime GPU 相关错误
3. **验证配置**: 确保 ONNX Runtime 配置正确

## 诊断步骤

### 步骤 1: 检查服务进程的环境变量 ✅
```bash
# 检查服务进程的环境变量
ps e -p $(ps aux | grep 'python app.py' | grep -v grep | awk '{print $2}') | grep LD_LIBRARY_PATH
```
**结果**: LD_LIBRARY_PATH 已设置: `/opt/conda/envs/human/lib:/usr/local/nvidia/lib:/usr/local/nvidia/lib64`

### 步骤 2: 检查 GPU 使用情况 ❌
```bash
# 监控 GPU 使用
nvidia-smi --query-gpu=index,utilization.gpu,memory.used --format=csv
```
**结果**: 所有 GPU 利用率为 0%

### 步骤 3: 检查 ONNX Runtime 配置 ✅
```bash
# 检查 ONNX Runtime 提供者
python check_env/check_onnx_cuda.py
```
**结果**: ONNX Runtime GPU 支持正常

### 步骤 4: 检查子进程环境变量 ⏳
```bash
# 检查子进程的环境变量
ps aux | grep multiprocessing | grep -v grep
```

## 预期结果

### 如果 GPU 正常使用
- GPU 利用率 > 0%
- 处理速度应该很快（每帧几毫秒）
- 队列不应该阻塞
- 150 帧视频应该在几分钟内完成

### 如果 GPU 未使用
- GPU 利用率为 0%
- 处理速度慢（每帧几秒）
- 队列容易阻塞
- 150 帧视频可能需要几十分钟

## 下一步

### 立即行动
1. **检查子进程环境变量**: 验证子进程是否继承了环境变量
2. **监控 GPU 使用**: 在任务执行时监控 GPU 利用率
3. **查看详细日志**: 分析任务执行过程
4. **检查 trans_dh_service.so**: 检查 .so 文件的依赖

### 后续优化
1. **优化环境变量传递**: 确保子进程能正确继承环境变量
2. **监控 GPU 使用**: 持续监控 GPU 使用情况
3. **优化队列配置**: 根据实际情况调整配置
4. **性能测试**: 进行完整的性能测试

## 总结

### 根本原因
**GPU 未被使用** - 这是队列阻塞的根本原因
- GPU 利用率为 0%
- 任务在 CPU 上运行
- 处理速度慢，导致队列阻塞

### 关键问题
1. **环境变量传递**: 子进程可能没有正确继承环境变量
2. **多进程环境**: multiprocessing.spawn 方式可能有问题
3. **ONNX Runtime 配置**: 实际运行时可能回退到 CPU

### 解决方案
1. **确保环境变量传递**: 在多个位置设置环境变量
2. **使用启动脚本**: 确保环境变量正确设置
3. **监控 GPU 使用**: 验证 GPU 是否被使用
4. **优化配置**: 根据实际情况调整配置

